<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>对DOM节点的增删改查</title>
</head>

<body>
    <!-- <div id="only"></div>
    <div class="haha"></div>
    <div class="haha"></div>
    <div class="haha"></div>
    <div class="haha"></div>
    <div class="haha"></div>
    <input type="text" name="fruit">
    <input type="text" name="fruit">
    <input type="text" name="fruit"> -->

    <!-- <div>
        <strong></strong>
    </div>
    <div>
        <span>
            <strong id="only" class="double">123</strong>
            <strong class="double">123</strong>
        </span>
    </div>
    <div>
        <p>123</p>
    </div>
    <p></p> -->

    <div> 123kas$%^
        <span></span>
        <strong>
            <span>123</span>
        </strong>
        <em></em>
        <i></i>
        <b></b>
    </div>
    <script>
        // document代表整个文档
        // var div = document.getElementById('only');//ie8以下的浏览器id不区分大小写,而且也返回匹配name属性的元素
        // var divs = document.getElementsByTagName('div');//没有任何兼容性问题
        // var divs = document.getElementsByClassName('haha');//ie9以下的浏览器没有这个方法
        // var ipts = document.getElementsByName('fruit');//老版本浏览器只有部分标签可以通过name属性选择出来,比如表单元素和其组件(因为name属性属于可以传输数据的元素的数据名)

        // var p = document.getElementsByTagName('p')[0];

        // 可以写css选择器的(ie8以下的浏览器没有这两种方法)
        // 一般不用这两种选择元素的方法,因为这两种方法" 不是实时的 ",一旦选中,则后续非元素结点类数组的操作不会改变类数组中所选中的元素结点
        // var strong = document.querySelector('div > span strong#only');
        // var strong = document.querySelectorAll('div > span strong.double');

// 遍历节点树
        // 节点的类型(6种): 元素结点->1 属性结点->2 文本节点(看起来全是空格的叫做文字分隔符文本)->3 注释结点->8 document->9  DocumentFragment->11
        // var strong = document.getElementsByTagName('strong')[0];
        // console.log(strong.parentNode);//parentNode可以进行链式操作

        // var div = document.getElementsByTagName('div')[0];
        // console.log(div.childNodes.length);//打印出DOM元素div的所有直接子元素结点的长度              
        // console.log(div.firstChild);
        // console.log(div.lastChild);

        // var strong = document.getElementsByTagName('strong')[0];
        // console.log(strong.nextSibling);
        // console.log(strong.previousSibling);

// 遍历元素结点数(除了children方法其余都是ie9以下不兼容的)
        // var div = document.getElementsByTagName('div')[0];
        // console.log(div.parentElement); //返回当前元素的元素父节点
        // console.log(div.parentElement.parentElement);
        // console.log(div.parentElement.parentElement.parentElement); //document自成一个结点
        // console.log(div.children); //只返回当前元素的元素子节点
        // // node.childElementCount === node.children.length;
        // console.log(div.firstElementChild);
        // console.log(div.lastElementChild);
        // var strong = document.getElementsByTagName('strong')[0];
        // console.log(strong.nextElementSibling);
        // console.log(strong.previousElementSibling);//返回后一个/前一个兄弟元素


// 节点的四个属性(nodeName nodeValue nodeType attributes)
        // 1.nodeName(元素的标签名,以大写形式表示,只读)
        // 2.nodeValue(Text结点或者Comment结点的文本内容,可以读写)
        // 3.nodeType(返回该结点的类型,只读)
        // 4.attributes(元素结点的属性集合)

// 封装一个方法,将div里面的所有元素结点装到一个数组里面返回(如果使用children就太简单了,但是这里考虑不使用children)
        var div = document.getElementsByTagName('div')[0];
        function returnEleChild(node) {
            var temp = {//用一个类数组存储node里面所有元素结点,这样temp返回值就和使用children的返回值很像了
                    length: 0,
                    push: Array.prototype.push,
                    splice: Array.prototype.splice//可以让对象长得更加像数组(其实就是类数组)
                },
                child = node.childNodes,
                len = child.length;
            for (var i = 0; i < len; i++) {
                if (child[i].nodeType === 1) {
                    temp.push(child[i]);
                }
            }
            return temp;
        }
        console.log(returnEleChild(div));

// setAttribute/getAttribute  ===  通过结点的attributes方法得到属性结点的类数组，对属性值进行读写操作

    </script>
</body>

</html>