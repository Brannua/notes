## 这里存放数据结构的笔记丫~

##### 基本概念

1. 解决问题的方法的效率，和**数据的组织方式**有关

2. 解决问题的方法的效率，和**空间的利用效率**有关

3. 解决问题的方法的效率，和**算法的巧妙程度**有关

##### 什么是数据结构？

1. 数据结构: 数据对象在计算机中的组织方式。
	> 数据对象的组织方式 > 逻辑结构 & 物理存储结构

2. 数据对象必定与一系列加在其上的操作相关联。

3. 完成这些操作所用的方法就是**算法**。

##### 抽象数据类型

1. 数据类型：数据对象集 & 数据集合相关联的操作集

2. 抽象：描述数据类型的方法不依赖于具体实现
	> 与存放数据的机器无关
	> 与数据存储的物理结构无关
	> 与实现操作的算法和编程语言均无关
- **即**只描述数据对象集和相关操作集是什么，并不涉及如何做到的问题

##### 什么是算法？

**算法:** 

1. 一个有限的指令集

2. 接受一些输入(有些情况下不需要输入)

3. 产生输出

4. 一定在有限步骤之后终止

5. 每一条指令必须
	> 有充分明确的目标，不可以有歧义
	> 计算机能够处理的范围之内
	> 描述应当不依赖于任何一种计算机语言以及具体的实现手段

##### 什么是好的算法？

1. 空间复杂度S(n): 根据算法写成的程序在执行时占用存储单元的长度，这个长度往往与**输入数据的规模**有关，空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断

2. 时间复杂度T(n): 根据算法写成的程序在执行时耗费时间的长度，这个长度往往也与**输入数据的规模**有关，时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果

3. 在分析一般算法的效率时，我们经常关注下面两种复杂度
	> 最坏情况复杂度T_worst(n)
	> 平均复杂度T_avg(n)
- T_avg(n) <= T_worst(n)

##### 复杂度的渐进表示法

`tips:` 

1. 每当看到一个算法的复杂度是n^2的，要下意识地考虑有没有办法将其降为n*logn

2. 若两段算法分别有复杂度T_1(n) = O(f_1(n))和T_2(n) = O(f_2(n))
	> T_1(n) + T_2(n) = max(O(f_1(n)), O(f_2(n)))
	> T_1(n) * T_2(n) = O(f_1(n)) * O(f_2(n))

3. 若T(n)是关于n的k阶多项式，那么T(n) = O(n^k)

4. 一个for循环的时间复杂度等于**循环次数乘以循环体代码的复杂度**

5. if-else结构的复杂度取决于if的条件判断复杂度和两个分支部分的复杂度，**总体复杂度取三者中最大的**

##### 应用实例

- 求最大子列和问题

`给定N个整数的序列{A1, A2, ..., AN},求函数f(i, j) = max{0, 最大子列和}的最大值`

> 实现细节见代码maxSubColSum.c
